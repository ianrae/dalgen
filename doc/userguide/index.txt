

Intro
----------
MEF is a fast TDD framework for Play Java applications.  It's based on the Robert Martin "entity-boundary-interactor" architecture described here.  

http://confreaks.net/videos/759-rubymidwest2011-keynote-architecture-the-lost-years

This architecture separates application code from any dependency on databases, the web, or even the Play framework.
The core of your app is POJO.  Unit tests run extremely fast (no need for entity manager or fakeApplication).

In MEF, each model class now becomes two classe: An "entity object" that contains only public fields, and a "DAO object" that manages persistence.  Entity and DAO classes are created with a code generation tool called mefgenerate.  It creates mock DAOs for unit testing, and real DALs for integration with your eBean or JPA Model object (which mefgeneration also creates).  The Model object is fully annotated with JPA and validation annotations.

Terminology
-------------
In his talk, Robert Martin, uses a number of terms, not because they are particularly elegant, but to avoid confusion with the 
existing model, view, controller terms.

 * Entity -- data-only object that represents a domain object. like a C struct.
 * Interactor -- contains business logic.  Receives requests and produces responses.
 * Boundary -- sits between the app and the MEF code, managing their interaction.
 * Gateway -- database persistence hidden behind interfaces.
 
MEF uses slightly different terminology.

 * Entity -- POJO class. no code. only public fields
 * Presenter -- contains business logic. 
 * Boundary -- same as above.
 * DAL -- Data Access Layer. Consists of one DAO per entity. database persistence.
 
Advantages
------------------
MEF apps are
 * faster to develop due to better TDD experience
 * easier to port if Play changes significantly or you want an Android version of your app
 * less boilerplate code to write. 
 
 
 



---------------------------------------------
TOC

Installing
see install.txt


Getting Started
Create a new play app, using play new. Then run the MEF code generation tool

mefgenerate app

This will create the mef directory structure and some intial files.

  app
    boundaries     layer that sits between Play and MEF

    mef
	    core   		 initialization code
	    dals        (daos) database persistence
	    entities    the 'model object in MEF (POJOs)
	    gen         codegen puts stuff here
	    presenters  holds business logic. equivalent to a controller

  conf
    mef/seed       JSON database initialization files

  test
    mef            unit tests (no FakeApplication needed)

Our app needs CRUD on a Task object, so we'll create a presenter that handles Tasks.

  mefgenerate presenter:Task

The following files are created

  app/mef/presenters/TaskPresenter      your business logic goes here
  app/mef/presenters/replies/TaskReply  response object
  test/mef/TaskPresenterTests           unit tests

The presenter contains methods for the standards RAILs actions.  You can use
them or delete them as needed.

In MEF, each action is represented by a public method of a presenter.
A naming convention is used; the method that processes an IndexCommand 
request is called onIndexCommand.

   Reply  onIndexCommand(IndexCommand cmd)

The command contains all the input data: CGI params, forms, cookies, etc.
The reply contains all the data needed by the view.  Reply can be considered
a form of viewmodel, although Play's excellent type-safe Scala views reduce
much of the need for classic viewmodels.

Now that our presenter exists, lets create the Task entity.  Edit mef.xml
in the application root directory.  You will be defining all your entities
in here.

Task will have two fields.  An id field is required by all entities.
And a name field.  Put in the JPA annotations.

<?xml version="1.0"?>
<entities orm="ebean"> 

<entity name="Task">
	<field>@Id Long id</field>
	<field>@Required String name</field>
</entity>
</entities>

Now generate the DAL by running

mefgenerate dal

The Task class is very simple:

public class Task extends Entity
{
    public Long id;
    public String name;
}

A number of other classes are created.  A mock and real DAO are created, both
implementing the DAO interface for Task:

public interface ITaskDAO  extends IDAO
{
	Task findById(long id);
	List<Task> all();
	void save(Task entity);        
	void update(Task entity);
}

This DAO is exensible. MEF will generate methods such as find_by_name automatically,
much like RAILS ActiveRecord. (See ....)

Our First Test
--------------
Under test/mef, a file TaskPresenterests.java has been created.

It contains a single test that sends an IndexCommand to the task presenter and
validates that the result.

	@Test
	public void indexTest() 
	{
		TaskReply reply = (TaskReply) _presenter.process(new IndexCommand());
		
		chkReplySucessful(reply, Reply.VIEW_INDEX, null);
		chkDalSize(0);
		chkReplyWithoutEntity(reply, true, 0);
	}

The reply returns a destination which can indicate a view to render or a redirect.
The destination is an integer so your controller can have a switch statement.
The DAO is empty by default so its size is zero.  (See xxx for seeding data)


Hooking up the Controller
---------------------------
In our controller, we call the presenter

	public static Result index() 
    {
		TaskBoundary boundary = TaskBoundary.create();
		TaskReply reply = boundary.process(new IndexCommand());
		return renderOrForward(boundary, reply);
	}

The TaskBoundary object was created by mefgenerate.  It knows how to convert Play forms to MEF form-binders.
All controller methods should call renderOrForward which handles generating a Play Result object.
in all the actions.


    private static Result renderOrForward(TaskBoundary boundary, TaskReply reply)
    {
		if (reply.failed()) //something bad happended
		{
			return redirect(routes.Main.errorPage());
		}
		
		switch(reply.getDestination())
		{
		case Reply.VIEW_INDEX:
			return ok(views.html.task.render(reply._allL, TaskForm));    	

		...

		case Reply.FORWARD_NOT_FOUND: 
			return redirect(routes.Main.notFoundPage());

		default:
			return redirect(routes.Main.errorPage());
    	}

The view for 'index' is given a list of Task entities.

@(tasks: List[mef.entities.Task])
@import helper._

@main("Tasks list") {
    
    <h1>@tasks.size() tasks(s)</h1>
    
    <ul>
        @for(task <- tasks) {
            <li>
                @user.name  @user.id   
            </li>
        }
    </ul>
}

The view receives entities, which means you can use field access, task.name, instead of getters.




---------------------------------
Code Generation
  mef.xml syntax
  finders
  custom methods
  customize
   -creates a parent class with _GEN suffix, put into mef/gen
   -then you manually create the DAL class and derive from the corresponding _gen class

   public class User extends User_GEN
	{


Creating a new app
 -one-time when first starting work on a new app
 -does not modify or overwrite any existing files
Creating a new presenter
 -done each time you create a new presenter
 -does not modify or overwrite any existing files
Updating the DAL
 -done each time you modify mef.xml
 -DOES overwrite existing files.  If you need to modify one of the DAL classes, use the customize option.

Controllers
-can now be as thin as possible. Business logic gets moved to the presenter
-however, you are free to adjust which code stays in the controller and which goes into the presenter.

Presenters
-one created per request to avoid multi-threading issues
-MEF uses reflection to call the action method for a particular command
-MEF defines Command classes for the RAILs action.  You generally use these unless there is additional input
  data you need to pass.  However you are free to create any type of command that you need.

An action method takes a command object as input, and produces a reply object as output.

Reply objects
-failed -- if true then the rest of the reply object is undefined.  Controllers should generally route to error page when
   failed() is true.

-destination. int. Defines what the application should do: render a view, or redirect somewhere.  
  -MEF defines some standard view and rediction values.  Define your own as needed.

-each type of presenter has its own reply class.  It contains fields for all the data that the presenter will be
returning.

CRUD actions

index
 -return a list of entities to display.  pagination support will be likely.

show(id)
 -show a single entity

new
 -show a form for creating a new instance of the entity

create
 -handle the postback from new.  Create the entity in the database.
 -if successful, create often redirects to index

edit(id)
 -show a form for editing an existing entity

update
 -handle the postback from edit. update the entity in the database
 -if successful, update often redirects to index

delete(id)
 -delete the entity
 -if successful, delete often redirects to index

Forms
Play has excellent forms with good validation support.  In MEF you will still
use Play forms.  However, your presenter never directly accesses them.

New
A 'new' action displays a form where the user create a new instance of an entity.

To generate a form, a presenter creates an entity object and fills in the default values
that you want each field to have when the form is displayed.  Back in the controller, call
the boundary's makeForm method.  This was created by mefgenerate and will create a Play
form from your entity.

		Form<TaskModel> frm = boundary.makeForm(reply); 

Create
The postback from 'new' has a the form.  In the controller, use the boundary method
addFormAndProcess.  This will create a Play form which is hidden from the presenter 
by a form-binder object. The presenter then does the binding via the form-binder.

		IFormBinder binder = cmd.getFormBinder();
		boolean valid = binder.bind();

If binder was not successful (due to validation failure(s)), the presenter returns the
form to the controller to render with appropriate validation messasges.



Database Access



Unit Testing



DB Seed



Integration testing


